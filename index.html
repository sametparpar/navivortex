<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>NaviVortex V15.13</title>
    <script src="https://cesium.com/downloads/cesiumjs/releases/1.114/Build/Cesium/Cesium.js"></script>
    <link href="https://cesium.com/downloads/cesiumjs/releases/1.114/Build/Cesium/Widgets/widgets.css" rel="stylesheet">
    <style>
        body, html, #cesiumContainer { width: 100%; height: 100%; margin: 0; padding: 0; overflow: hidden; background-color: #000; }
        #dashboard {
            position: absolute; top: 20px; left: 20px; width: 260px; 
            background: rgba(15, 23, 42, 0.9); z-index: 100; padding: 20px;
            border-radius: 12px; font-family: sans-serif; color: white; border: 1px solid #38bdf8;
        }
        .btn { width: 100%; padding: 12px; margin-top: 10px; border-radius: 6px; border: none; cursor: pointer; font-weight: bold; text-transform: uppercase; }
        #start-btn { background: #10b981; color: white; display: none; }
        #lock-btn { background: #0ea5e9; color: white; }
        .reset-btn { background: #ef4444; color: white; margin-top: 20px; font-size: 10px; }
    </style>
</head>
<body>
    <div id="dashboard">
        <h2 style="margin:0 0 10px 0; color:#38bdf8;">NAVIVORTEX V53</h2>
        <div id="alt-txt">Altitude: 100 m</div>
        <button id="lock-btn" class="btn" onclick="toggleLock()">ðŸ”’ LOCK MISSION</button>
        <button id="start-btn" class="btn" onclick="startFlight()">ðŸš€ START FLIGHT</button>
        <button class="btn reset-btn" onclick="location.reload()">RESET SYSTEM</button>
    </div>
    <div id="cesiumContainer"></div>

    <script>
        Cesium.Ion.defaultAccessToken = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJqdGkiOiIzMzEyYzc1OS03OTY0LTQ5MGYtODcwMi0zMGNiYmZjNGIxMTkiLCJpZCI6Mzc2MTk2LCJpYXQiOjE3Njc4NjA4NjJ9.aZRZorILCG4gIlzwCnm1L2SCp58z-TCg6yNaDbPLxnU';
        const GOOGLE_API_KEY = 'AIzaSyDDPGFsMFFW8Q8s9Y-2aonzk6LofSBuhps';

        const viewer = new Cesium.Viewer('cesiumContainer', {
            terrain: Cesium.Terrain.fromWorldTerrain(),
            animation: false, timeline: false, baseLayerPicker: false
        });

        // GÃ¶rsel Stabilite AyarlarÄ±
        viewer.scene.globe.depthTestAgainstTerrain = false;
        viewer.scene.camera.frustum.near = 0.1;

        let drone, waypoints = [], isLocked = false, isFlying = false, heading = 0;
        let dronePos = Cesium.Cartesian3.fromDegrees(28.9784, 41.0082, 100);
        let initialHomePos;
        let currentAGL = 100; // Drone baÅŸlangÄ±Ã§ta yerden 100m yÃ¼ksekte olsun

        async function init() {
            try {
                const tileset = await Cesium.createGooglePhotorealistic3DTileset(GOOGLE_API_KEY);
                viewer.scene.primitives.add(tileset);
            } catch (e) { console.error("Tileset yÃ¼klenemedi:", e); }

            drone = viewer.entities.add({
                position: new Cesium.CallbackProperty(() => dronePos, false),
                orientation: new Cesium.CallbackProperty(() => {
                    return Cesium.Transforms.headingPitchRollQuaternion(dronePos, new Cesium.HeadingPitchRoll(Cesium.Math.toRadians(heading), 0, 0));
                }, false),
                model: { 
                    uri: 'https://raw.githubusercontent.com/CesiumGS/cesium/main/Apps/SampleData/models/CesiumDrone/CesiumDrone.glb', 
                    minimumPixelSize: 80,
                    disableDepthTestDistance: Number.POSITIVE_INFINITY 
                }
            });

            viewer.camera.flyTo({ destination: Cesium.Cartesian3.fromDegrees(28.9784, 41.0082, 400) });

            const handler = new Cesium.ScreenSpaceEventHandler(viewer.scene.canvas);
handler.setInputAction((click) => {
    if (isLocked || isFlying) return;
    
    const picked = viewer.scene.pickPosition(click.position);
if (Cesium.defined(picked)) {
    const carto = Cesium.Cartographic.fromCartesian(picked);
    
    // TÄ±klanan noktanÄ±n altÄ±ndaki zemini Ã¶lÃ§
    const groundAtPoint = viewer.scene.sampleHeight(carto) || 0;
    
    // Drone'un o anki yerden yÃ¼ksekliÄŸini (AGL) al
    const droneCarto = Cesium.Cartographic.fromCartesian(dronePos);
    const droneGround = viewer.scene.sampleHeight(droneCarto) || 0;
    const currentAGL = droneCarto.height - droneGround;

    // NoktayÄ±: (TÄ±klanan yerin zemini) + (Drone'un yerden yÃ¼ksekliÄŸi) ÅŸeklinde koy
const fixedPos = Cesium.Cartesian3.fromRadians(
    carto.longitude, 
    carto.latitude, 
    groundAtPoint + currentAGL
);

    if (waypoints.length === 0) initialHomePos = dronePos;
    // ... geri kalan wp tanÄ±mlarÄ± aynÄ± kalabilir
    

        const wp = {
            pos: fixedPos,
            entity: viewer.entities.add({
                position: new Cesium.CallbackProperty(() => wp.pos, false),
                point: { pixelSize: 10, color: Cesium.Color.YELLOW, disableDepthTestDistance: Number.POSITIVE_INFINITY }
            }),

anchor: viewer.entities.add({
    polyline: {
        positions: new Cesium.CallbackProperty(() => {
            const carto = Cesium.Cartographic.fromCartesian(wp.pos);
            // BulunduÄŸumuz yerin tam yÃ¼ksekliÄŸini Ã¶lÃ§ (EÄŸer Ã¶lÃ§emezse 0 al)
            const terrainHeight = viewer.scene.sampleHeight(carto) || 0;
            const groundPos = Cesium.Cartesian3.fromRadians(carto.longitude, carto.latitude, terrainHeight);
            return [groundPos, wp.pos];
        }, false),
        width: 2,
        material: new Cesium.PolylineDashMaterialProperty({
            color: Cesium.Color.WHITE.withAlpha(0.7),
            dashLength: 8
        }),
        disableDepthTestDistance: Number.POSITIVE_INFINITY 
    }
}),
            
            line: viewer.entities.add({
                polyline: {
                    positions: new Cesium.CallbackProperty(() => {
                        let idx = waypoints.indexOf(wp);
                        let start = (idx === 0) ? initialHomePos : waypoints[idx-1].pos;
                        return [start, wp.pos];
                    }, false),
                    width: 6,
                    material: Cesium.Color.GREEN,
                    depthFailMaterial: Cesium.Color.GREEN,
                    disableDepthTestDistance: Number.POSITIVE_INFINITY,
                    arcType: Cesium.ArcType.NONE
                }
            })
        };
        waypoints.push(wp);
    }
}, Cesium.ScreenSpaceEventType.LEFT_CLICK);
        }

        document.addEventListener('keydown', (e) => {
    if (isLocked || isFlying) return;
    
    const c = Cesium.Cartographic.fromCartesian(dronePos);
    let lon = Cesium.Math.toDegrees(c.longitude);
    let lat = Cesium.Math.toDegrees(c.latitude);
    
    // 1. AltÄ±mÄ±zdaki zeminin yÃ¼ksekliÄŸini Ã¶lÃ§Ã¼yoruz
    const groundHeight = viewer.scene.sampleHeight(c) || 0;
    
    // 2. Mevcut yerden yÃ¼ksekliÄŸimizi hesaplÄ±yoruz (Deniz Seviyesi - Zemin)
    let currentAGL = c.height - groundHeight;
    
    const k = e.key.toLowerCase();
    
    // 3. TuÅŸlara basÄ±nca deniz seviyesini deÄŸil, "Yerden YÃ¼ksekliÄŸi" deÄŸiÅŸtiriyoruz
    if (k === 'q') currentAGL += 5; // Yerden 5 metre daha yÃ¼ksel
    if (k === 'e') currentAGL = Math.max(2, currentAGL - 5); // Yere en fazla 2 metre yaklaÅŸ
            
    
    // 4. Yeni konumu: Zemin + Yeni Yerden YÃ¼kseklik olarak belirliyoruz
    dronePos = Cesium.Cartesian3.fromDegrees(lon, lat, groundHeight + currentAGL);
    
    document.getElementById('alt-txt').innerText = "Yerden YÃ¼kseklik: " + Math.round(currentAGL) + " m";
});

        function toggleLock() {
            if (waypoints.length === 0) return;
            isLocked = !isLocked;
            document.getElementById('start-btn').style.display = isLocked ? "block" : "none";
            document.getElementById('lock-btn').innerText = isLocked ? "ðŸ”“ UNLOCK" : "ðŸ”’ LOCK MISSION";
        }

        async function startFlight() {
            isFlying = true;
            viewer.trackedEntity = drone;
            let currentPos = dronePos;
            for (const wp of waypoints) {
                const start = currentPos;
                const end = wp.pos;
                const duration = Cesium.Cartesian3.distance(start, end) / 20;
                await new Promise(resolve => {
                    let startTime = performance.now();
                    function frame(now) {
                        let t = Math.min((now - startTime) / (duration * 1000), 1);
                        dronePos = Cesium.Cartesian3.lerp(start, end, t, new Cesium.Cartesian3());
                        if (t < 1) requestAnimationFrame(frame); else resolve();
                    }
                    requestAnimationFrame(frame);
                });
                currentPos = end;
            }
            isFlying = false;
            viewer.trackedEntity = undefined;
        }

        init();
    </script>
</body>
</html>















